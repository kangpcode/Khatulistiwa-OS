/*
 * ============================================================================
 * overlay.khat - Layout Floating Overlay dengan Animasi Garuda Khatulistiwa OS
 * Copyright (c) 2025 Dhafa Nazula Permadi & Team BIGCode By Cv Bintang Gumilang Group
 * ============================================================================
 * 
 * Overlay layout engine dengan fitur:
 * 1. Floating windows dengan animasi garuda terbang
 * 2. Picture-in-picture mode dengan ornamen tradisional
 * 3. Smart positioning dengan magnetic snap
 * 4. Transparency effects dengan motif batik
 * 5. Gesture controls dengan budaya Indonesia
 */

import "khatcore/system.khat"
import "khatui/runtime.khat"
import "khatui/cultural.khat"
import "khatui/animations.khat"

// Konstanta overlay layout
konstan OVERLAY_VERSION = "1.0.0"
konstan MAX_OVERLAYS = 16
konstan MIN_OVERLAY_SIZE = 150
konstan SNAP_DISTANCE = 25
konstan FADE_DURATION = 200
konstan GARUDA_ANIMATION_DURATION = 500

// Tipe overlay
enum OverlayType {
    FLOATING = 0,          // Window mengambang bebas
    PICTURE_IN_PICTURE = 1, // PiP mode untuk video
    NOTIFICATION = 2,       // Notifikasi mengambang
    WIDGET = 3,            // Widget desktop
    TOOLTIP = 4,           // Tooltip informasi
    MODAL = 5              // Dialog modal
}

// Posisi snap
enum SnapPosition {
    NONE = 0,
    TOP_LEFT = 1,
    TOP_RIGHT = 2,
    BOTTOM_LEFT = 3,
    BOTTOM_RIGHT = 4,
    CENTER = 5,
    TOP_CENTER = 6,
    BOTTOM_CENTER = 7,
    LEFT_CENTER = 8,
    RIGHT_CENTER = 9
}

// Struktur overlay window
struct OverlayWindow {
    id: int,
    window_id: int,
    type: OverlayType,
    x: int,
    y: int,
    width: int,
    height: int,
    min_width: int,
    min_height: int,
    opacity: float,
    target_opacity: float,
    scale: float,
    target_scale: float,
    rotation: float,
    snap_position: SnapPosition,
    is_dragging: bool,
    is_resizing: bool,
    is_visible: bool,
    is_pinned: bool,
    auto_hide: bool,
    hide_timeout: int,
    cultural_theme: string,
    garuda_style: string,
    batik_pattern: string,
    animation_state: int,
    animation_progress: float,
    shadow_enabled: bool,
    border_enabled: bool,
    last_interaction: time_t,
    creation_time: time_t
}

// State overlay layout
struct OverlayLayoutState {
    overlays: OverlayWindow[],
    overlay_count: int,
    active_overlay: int,
    screen_width: int,
    screen_height: int,
    cultural_mode: bool,
    animation_enabled: bool,
    transparency_enabled: bool,
    snap_enabled: bool,
    magnetic_snap: bool,
    drag_overlay: int,
    drag_start_x: int,
    drag_start_y: int,
    drag_offset_x: int,
    drag_offset_y: int,
    snap_zones: SnapZone[],
    snap_zone_count: int
}

// Zona snap magnetik
struct SnapZone {
    position: SnapPosition,
    x: int,
    y: int,
    width: int,
    height: int,
    is_active: bool,
    cultural_indicator: string
}

// Global state
var overlay_layout: OverlayLayoutState

// Inisialisasi overlay layout
fungsi overlay_init() -> int {
    khat_log("[OVERLAY] Menginisialisasi Overlay Layout v" + OVERLAY_VERSION)
    
    // Setup state awal
    overlay_layout.overlay_count = 0
    overlay_layout.active_overlay = -1
    overlay_layout.screen_width = khat_screen_width()
    overlay_layout.screen_height = khat_screen_height()
    overlay_layout.cultural_mode = true
    overlay_layout.animation_enabled = true
    overlay_layout.transparency_enabled = true
    overlay_layout.snap_enabled = true
    overlay_layout.magnetic_snap = true
    overlay_layout.drag_overlay = -1
    
    // Initialize snap zones
    init_snap_zones()
    
    // Initialize cultural themes
    init_garuda_themes()
    
    khat_log("[OVERLAY] Overlay Layout berhasil diinisialisasi!")
    return 0
}

// Initialize snap zones
fungsi init_snap_zones() -> void {
    overlay_layout.snap_zone_count = 9
    
    var margin = 20
    var zone_size = 100
    
    // Top-left
    overlay_layout.snap_zones[0] = {TOP_LEFT, margin, margin, zone_size, zone_size, false, "sudut_kiri_atas"}
    
    // Top-right
    overlay_layout.snap_zones[1] = {TOP_RIGHT, overlay_layout.screen_width - margin - zone_size, margin, zone_size, zone_size, false, "sudut_kanan_atas"}
    
    // Bottom-left
    overlay_layout.snap_zones[2] = {BOTTOM_LEFT, margin, overlay_layout.screen_height - margin - zone_size, zone_size, zone_size, false, "sudut_kiri_bawah"}
    
    // Bottom-right
    overlay_layout.snap_zones[3] = {BOTTOM_RIGHT, overlay_layout.screen_width - margin - zone_size, overlay_layout.screen_height - margin - zone_size, zone_size, zone_size, false, "sudut_kanan_bawah"}
    
    // Center
    overlay_layout.snap_zones[4] = {CENTER, (overlay_layout.screen_width - zone_size) / 2, (overlay_layout.screen_height - zone_size) / 2, zone_size, zone_size, false, "tengah_layar"}
    
    // Top-center
    overlay_layout.snap_zones[5] = {TOP_CENTER, (overlay_layout.screen_width - zone_size) / 2, margin, zone_size, zone_size, false, "tengah_atas"}
    
    // Bottom-center
    overlay_layout.snap_zones[6] = {BOTTOM_CENTER, (overlay_layout.screen_width - zone_size) / 2, overlay_layout.screen_height - margin - zone_size, zone_size, zone_size, false, "tengah_bawah"}
    
    // Left-center
    overlay_layout.snap_zones[7] = {LEFT_CENTER, margin, (overlay_layout.screen_height - zone_size) / 2, zone_size, zone_size, false, "tengah_kiri"}
    
    // Right-center
    overlay_layout.snap_zones[8] = {RIGHT_CENTER, overlay_layout.screen_width - margin - zone_size, (overlay_layout.screen_height - zone_size) / 2, zone_size, zone_size, false, "tengah_kanan"}
}

// Buat overlay window baru
fungsi overlay_create_window(window_id: int, type: OverlayType, x: int, y: int, 
                            width: int, height: int) -> int {
    if (overlay_layout.overlay_count >= MAX_OVERLAYS) {
        khat_log("[OVERLAY] Maximum overlays reached")
        return -1
    }
    
    var overlay_id = overlay_layout.overlay_count
    var overlay: OverlayWindow
    
    // Setup overlay properties
    overlay.id = overlay_id
    overlay.window_id = window_id
    overlay.type = type
    overlay.x = x
    overlay.y = y
    overlay.width = width
    overlay.height = height
    overlay.min_width = MIN_OVERLAY_SIZE
    overlay.min_height = MIN_OVERLAY_SIZE
    overlay.opacity = 0.0  // Start invisible
    overlay.target_opacity = get_default_opacity(type)
    overlay.scale = 0.5    // Start small
    overlay.target_scale = 1.0
    overlay.rotation = 0.0
    overlay.snap_position = NONE
    overlay.is_dragging = false
    overlay.is_resizing = false
    overlay.is_visible = true
    overlay.is_pinned = false
    overlay.auto_hide = (type == NOTIFICATION || type == TOOLTIP)
    overlay.hide_timeout = get_auto_hide_timeout(type)
    overlay.cultural_theme = get_overlay_cultural_theme(type)
    overlay.garuda_style = get_garuda_style(type)
    overlay.batik_pattern = get_overlay_batik_pattern(type)
    overlay.animation_state = 0
    overlay.animation_progress = 0.0
    overlay.shadow_enabled = true
    overlay.border_enabled = true
    overlay.last_interaction = khat_get_current_time()
    overlay.creation_time = overlay.last_interaction
    
    // Validasi posisi
    validate_overlay_position(&overlay)
    
    // Tambah ke daftar overlays
    overlay_layout.overlays[overlay_id] = overlay
    overlay_layout.overlay_count++
    overlay_layout.active_overlay = overlay_id
    
    // Start entrance animation
    if (overlay_layout.animation_enabled) {
        start_overlay_entrance_animation(overlay_id)
    } else {
        // Langsung tampilkan
        overlay.opacity = overlay.target_opacity
        overlay.scale = overlay.target_scale
    }
    
    khat_log("[OVERLAY] Overlay window created (ID: " + khat_int_to_string(overlay_id) + ")")
    return overlay_id
}

// Validasi posisi overlay
fungsi validate_overlay_position(overlay: OverlayWindow*) -> void {
    // Pastikan overlay tidak keluar dari layar
    if (overlay->x < 0) {
        overlay->x = 0
    }
    if (overlay->y < 0) {
        overlay->y = 0
    }
    if (overlay->x + overlay->width > overlay_layout.screen_width) {
        overlay->x = overlay_layout.screen_width - overlay->width
    }
    if (overlay->y + overlay->height > overlay_layout.screen_height) {
        overlay->y = overlay_layout.screen_height - overlay->height
    }
}

// Start entrance animation dengan garuda
fungsi start_overlay_entrance_animation(overlay_id: int) -> void {
    if (overlay_id < 0 || overlay_id >= overlay_layout.overlay_count) {
        return
    }
    
    var overlay = &overlay_layout.overlays[overlay_id]
    
    // Garuda flying in animation
    overlay->animation_state = 1  // Entrance
    overlay->animation_progress = 0.0
    
    // Start dari posisi di luar layar (garuda terbang masuk)
    var entrance_style = overlay->garuda_style
    
    if (entrance_style == "garuda_from_sky") {
        // Masuk dari atas seperti garuda turun
        overlay->y = -overlay->height
        overlay->rotation = -15.0  // Slight tilt
    } else if (entrance_style == "garuda_from_horizon") {
        // Masuk dari samping seperti garuda terbang horizontal
        overlay->x = -overlay->width
        overlay->rotation = 5.0
    } else {
        // Default: fade in dengan scale
        overlay->scale = 0.3
        overlay->opacity = 0.0
    }
    
    // Play entrance sound
    play_garuda_entrance_sound(entrance_style)
}

// Update animasi overlay
fungsi update_overlay_animations() -> void {
    for (var i = 0; i < overlay_layout.overlay_count; i++) {
        var overlay = &overlay_layout.overlays[i]
        
        if (overlay->animation_state > 0) {
            update_single_overlay_animation(overlay)
        }
        
        // Update opacity transition
        if (overlay->opacity != overlay->target_opacity) {
            var opacity_speed = 0.05
            if (overlay->opacity < overlay->target_opacity) {
                overlay->opacity += opacity_speed
                if (overlay->opacity > overlay->target_opacity) {
                    overlay->opacity = overlay->target_opacity
                }
            } else {
                overlay->opacity -= opacity_speed
                if (overlay->opacity < overlay->target_opacity) {
                    overlay->opacity = overlay->target_opacity
                }
            }
        }
        
        // Update scale transition
        if (overlay->scale != overlay->target_scale) {
            var scale_speed = 0.03
            if (overlay->scale < overlay->target_scale) {
                overlay->scale += scale_speed
                if (overlay->scale > overlay->target_scale) {
                    overlay->scale = overlay->target_scale
                }
            } else {
                overlay->scale -= scale_speed
                if (overlay->scale < overlay->target_scale) {
                    overlay->scale = overlay->target_scale
                }
            }
        }
        
        // Auto-hide check
        if (overlay->auto_hide && !overlay->is_pinned) {
            var current_time = khat_get_current_time()
            if (current_time - overlay->last_interaction > overlay->hide_timeout) {
                start_overlay_exit_animation(i)
            }
        }
    }
}

// Update animasi single overlay
fungsi update_single_overlay_animation(overlay: OverlayWindow*) -> void {
    overlay->animation_progress += 0.02  // 2% per frame
    
    if (overlay->animation_progress >= 1.0) {
        overlay->animation_progress = 1.0
        overlay->animation_state = 0  // Animation complete
        
        // Reset rotation
        overlay->rotation = 0.0
        
        return
    }
    
    var progress = overlay->animation_progress
    var eased_progress = ease_out_cubic(progress)
    
    if (overlay->animation_state == 1) {
        // Entrance animation
        if (overlay->garuda_style == "garuda_from_sky") {
            // Animate Y position
            var target_y = overlay->y + overlay->height  // Final position
            overlay->y = lerp(-overlay->height, target_y, eased_progress)
            
            // Animate rotation (garuda landing)
            overlay->rotation = lerp(-15.0, 0.0, eased_progress)
        } else if (overlay->garuda_style == "garuda_from_horizon") {
            // Animate X position
            var target_x = overlay->x + overlay->width  // Final position
            overlay->x = lerp(-overlay->width, target_x, eased_progress)
            
            // Animate rotation (garuda straightening)
            overlay->rotation = lerp(5.0, 0.0, eased_progress)
        }
        
        // Animate opacity and scale
        overlay->opacity = lerp(0.0, overlay->target_opacity, eased_progress)
        overlay->scale = lerp(0.3, overlay->target_scale, eased_progress)
        
    } else if (overlay->animation_state == 2) {
        // Exit animation (reverse of entrance)
        var reverse_progress = 1.0 - eased_progress
        
        overlay->opacity = lerp(0.0, overlay->target_opacity, reverse_progress)
        overlay->scale = lerp(0.3, overlay->target_scale, reverse_progress)
        
        if (overlay->garuda_style == "garuda_from_sky") {
            overlay->rotation = lerp(0.0, 15.0, progress)  // Tilt up when leaving
        }
    }
}

// Easing function
fungsi ease_out_cubic(t: float) -> float {
    var t1 = t - 1.0
    return 1.0 + t1 * t1 * t1
}

// Linear interpolation
fungsi lerp(start: float, end: float, t: float) -> float {
    return start + (end - start) * t
}

// Handle drag overlay
fungsi overlay_start_drag(overlay_id: int, mouse_x: int, mouse_y: int) -> int {
    if (overlay_id < 0 || overlay_id >= overlay_layout.overlay_count) {
        return -1
    }
    
    var overlay = &overlay_layout.overlays[overlay_id]
    
    overlay->is_dragging = true
    overlay_layout.drag_overlay = overlay_id
    overlay_layout.drag_start_x = mouse_x
    overlay_layout.drag_start_y = mouse_y
    overlay_layout.drag_offset_x = mouse_x - overlay->x
    overlay_layout.drag_offset_y = mouse_y - overlay->y
    
    // Bring to front
    bring_overlay_to_front(overlay_id)
    
    // Show snap zones jika magnetic snap enabled
    if (overlay_layout.magnetic_snap) {
        show_snap_zones()
    }
    
    // Update interaction time
    overlay->last_interaction = khat_get_current_time()
    
    return 0
}

// Handle drag movement
fungsi overlay_handle_drag(mouse_x: int, mouse_y: int) -> void {
    if (overlay_layout.drag_overlay < 0) {
        return
    }
    
    var overlay = &overlay_layout.overlays[overlay_layout.drag_overlay]
    
    // Calculate new position
    var new_x = mouse_x - overlay_layout.drag_offset_x
    var new_y = mouse_y - overlay_layout.drag_offset_y
    
    // Check for magnetic snap
    if (overlay_layout.magnetic_snap) {
        var snap_pos = check_magnetic_snap(new_x, new_y, overlay->width, overlay->height)
        if (snap_pos != NONE) {
            apply_snap_position(overlay, snap_pos)
            highlight_snap_zone(snap_pos)
            return
        }
    }
    
    // Update position
    overlay->x = new_x
    overlay->y = new_y
    
    // Validate bounds
    validate_overlay_position(overlay)
    
    // Clear snap highlights
    clear_snap_zone_highlights()
}

// Stop drag
fungsi overlay_stop_drag() -> void {
    if (overlay_layout.drag_overlay < 0) {
        return
    }
    
    var overlay = &overlay_layout.overlays[overlay_layout.drag_overlay]
    overlay->is_dragging = false
    
    // Hide snap zones
    hide_snap_zones()
    
    // Play drop sound
    play_cultural_drop_sound()
    
    overlay_layout.drag_overlay = -1
}

// Check magnetic snap
fungsi check_magnetic_snap(x: int, y: int, width: int, height: int) -> SnapPosition {
    if (!overlay_layout.snap_enabled) {
        return NONE
    }
    
    var center_x = x + width / 2
    var center_y = y + height / 2
    
    for (var i = 0; i < overlay_layout.snap_zone_count; i++) {
        var zone = &overlay_layout.snap_zones[i]
        
        var zone_center_x = zone->x + zone->width / 2
        var zone_center_y = zone->y + zone->height / 2
        
        var distance = sqrt((center_x - zone_center_x) * (center_x - zone_center_x) + 
                           (center_y - zone_center_y) * (center_y - zone_center_y))
        
        if (distance < SNAP_DISTANCE) {
            return zone->position
        }
    }
    
    return NONE
}

// Apply snap position
fungsi apply_snap_position(overlay: OverlayWindow*, position: SnapPosition) -> void {
    var margin = 20
    
    switch (position) {
        case TOP_LEFT:
            overlay->x = margin
            overlay->y = margin
            break
        case TOP_RIGHT:
            overlay->x = overlay_layout.screen_width - overlay->width - margin
            overlay->y = margin
            break
        case BOTTOM_LEFT:
            overlay->x = margin
            overlay->y = overlay_layout.screen_height - overlay->height - margin
            break
        case BOTTOM_RIGHT:
            overlay->x = overlay_layout.screen_width - overlay->width - margin
            overlay->y = overlay_layout.screen_height - overlay->height - margin
            break
        case CENTER:
            overlay->x = (overlay_layout.screen_width - overlay->width) / 2
            overlay->y = (overlay_layout.screen_height - overlay->height) / 2
            break
        case TOP_CENTER:
            overlay->x = (overlay_layout.screen_width - overlay->width) / 2
            overlay->y = margin
            break
        case BOTTOM_CENTER:
            overlay->x = (overlay_layout.screen_width - overlay->width) / 2
            overlay->y = overlay_layout.screen_height - overlay->height - margin
            break
        case LEFT_CENTER:
            overlay->x = margin
            overlay->y = (overlay_layout.screen_height - overlay->height) / 2
            break
        case RIGHT_CENTER:
            overlay->x = overlay_layout.screen_width - overlay->width - margin
            overlay->y = (overlay_layout.screen_height - overlay->height) / 2
            break
    }
    
    overlay->snap_position = position
}

// Render overlay window
fungsi overlay_render_window(overlay_id: int) -> void {
    if (overlay_id < 0 || overlay_id >= overlay_layout.overlay_count) {
        return
    }
    
    var overlay = &overlay_layout.overlays[overlay_id]
    
    if (!overlay->is_visible || overlay->opacity <= 0.0) {
        return
    }
    
    // Calculate scaled dimensions
    var scaled_width = (int)(overlay->width * overlay->scale)
    var scaled_height = (int)(overlay->height * overlay->scale)
    var scaled_x = overlay->x + (overlay->width - scaled_width) / 2
    var scaled_y = overlay->y + (overlay->height - scaled_height) / 2
    
    // Render shadow jika enabled
    if (overlay->shadow_enabled) {
        render_overlay_shadow(scaled_x, scaled_y, scaled_width, scaled_height, overlay->opacity)
    }
    
    // Render border dengan ornamen budaya
    if (overlay->border_enabled) {
        render_cultural_overlay_border(scaled_x, scaled_y, scaled_width, scaled_height, 
                                       overlay->cultural_theme, overlay->opacity)
    }
    
    // Render window content dengan transformasi
    render_transformed_window_content(overlay->window_id, scaled_x, scaled_y, 
                                      scaled_width, scaled_height, 
                                      overlay->opacity, overlay->rotation)
    
    // Render overlay controls
    if (overlay->type == FLOATING || overlay->type == PICTURE_IN_PICTURE) {
        render_overlay_controls(overlay)
    }
}

// Render semua overlays
fungsi overlay_render_all() -> void {
    // Update animations
    update_overlay_animations()
    
    // Render snap zones jika sedang drag
    if (overlay_layout.drag_overlay >= 0 && overlay_layout.magnetic_snap) {
        render_snap_zones()
    }
    
    // Render overlays berdasarkan z-order
    for (var i = 0; i < overlay_layout.overlay_count; i++) {
        overlay_render_window(i)
    }
}

// API untuk WindowManager
fungsi overlay_get_overlay_count() -> int {
    return overlay_layout.overlay_count
}

fungsi overlay_destroy_window(overlay_id: int) -> int {
    if (overlay_id < 0 || overlay_id >= overlay_layout.overlay_count) {
        return -1
    }
    
    // Start exit animation
    start_overlay_exit_animation(overlay_id)
    
    return 0
}

// Start exit animation
fungsi start_overlay_exit_animation(overlay_id: int) -> void {
    if (overlay_id < 0 || overlay_id >= overlay_layout.overlay_count) {
        return
    }
    
    var overlay = &overlay_layout.overlays[overlay_id]
    overlay->animation_state = 2  // Exit
    overlay->animation_progress = 0.0
    
    // Play exit sound
    play_garuda_exit_sound(overlay->garuda_style)
}

// Entry point untuk testing
fungsi main() -> int {
    if (overlay_init() != 0) {
        return -1
    }
    
    khat_log("[OVERLAY] Overlay Layout ready for testing")
    return 0
}
