/*
 * ============================================================================
 * process_scheduler.khat - Process Scheduler dengan Konsep Gotong Royong
 * Copyright (c) 2025 Dhafa Nazula Permadi & Team BIGCode By Cv Bintang Gumilang Group
 * ============================================================================
 * 
 * Process scheduler dengan fitur:
 * 1. Cooperative scheduling dengan gotong royong
 * 2. Priority scheduling dengan sistem kepemimpinan adat
 * 3. Load balancing dengan pembagian kerja tradisional
 * 4. Cultural process management
 * 5. Real-time scheduling untuk aplikasi budaya
 */

// Konstanta scheduler
konstan MAX_PRIORITY = 10
konstan MIN_PRIORITY = 0
konstan TIME_SLICE_MS = 10
konstan CULTURAL_PRIORITY_BOOST = 2
konstan GOTONG_ROYONG_THRESHOLD = 5

// Scheduling algorithms
enum SchedulingAlgorithm {
    ROUND_ROBIN = 0,
    PRIORITY = 1,
    GOTONG_ROYONG = 2,  // Cooperative scheduling
    CULTURAL_AWARE = 3,  // Cultural priority scheduling
    REAL_TIME = 4
}

// Process priority classes
enum PriorityClass {
    IDLE = 0,           // Background processes
    NORMAL = 1,         // Normal user processes
    HIGH = 2,           // Important processes
    CULTURAL = 3,       // Cultural applications
    SYSTEM = 4,         // System processes
    REAL_TIME = 5       // Real-time processes
}

// Struktur scheduler queue
struct SchedulerQueue {
    processes: int[1024],
    process_count: int,
    current_index: int,
    priority_level: int,
    cultural_boost: bool,
    last_scheduled: time_t
}

// Struktur process scheduling info
struct ProcessSchedulingInfo {
    pid: int,
    priority: int,
    priority_class: PriorityClass,
    time_slice: int,
    cpu_time_used: time_t,
    wait_time: time_t,
    last_scheduled: time_t,
    cultural_priority: bool,
    gotong_royong_contribution: int,
    scheduling_count: int,
    context_switches: int
}

// Scheduler statistics
struct SchedulerStats {
    total_processes: int,
    running_processes: int,
    waiting_processes: int,
    cultural_processes: int,
    context_switches: int,
    average_wait_time: time_t,
    average_turnaround_time: time_t,
    cpu_utilization: float,
    gotong_royong_efficiency: float
}

// Global scheduler state
var scheduler_queues: SchedulerQueue[MAX_PRIORITY + 1]
var process_scheduling_info: ProcessSchedulingInfo[1024]
var current_algorithm: SchedulingAlgorithm
var scheduler_stats: SchedulerStats
var scheduler_lock: int
var last_schedule_time: time_t
var gotong_royong_active: bool

// Inisialisasi scheduler
fungsi scheduler_init() -> int {
    khat_log("[SCHEDULER] Menginisialisasi Process Scheduler Gotong Royong")
    
    // Initialize scheduler queues
    for (var i = 0; i <= MAX_PRIORITY; i++) {
        scheduler_queues[i].process_count = 0
        scheduler_queues[i].current_index = 0
        scheduler_queues[i].priority_level = i
        scheduler_queues[i].cultural_boost = false
        scheduler_queues[i].last_scheduled = 0
    }
    
    // Initialize scheduling info array
    for (var i = 0; i < 1024; i++) {
        process_scheduling_info[i].pid = -1
        process_scheduling_info[i].priority = MIN_PRIORITY
        process_scheduling_info[i].priority_class = NORMAL
        process_scheduling_info[i].time_slice = TIME_SLICE_MS
        process_scheduling_info[i].cpu_time_used = 0
        process_scheduling_info[i].wait_time = 0
        process_scheduling_info[i].last_scheduled = 0
        process_scheduling_info[i].cultural_priority = false
        process_scheduling_info[i].gotong_royong_contribution = 0
        process_scheduling_info[i].scheduling_count = 0
        process_scheduling_info[i].context_switches = 0
    }
    
    // Set default algorithm
    current_algorithm = GOTONG_ROYONG
    scheduler_lock = 0
    last_schedule_time = 0
    gotong_royong_active = true
    
    // Initialize statistics
    scheduler_stats.total_processes = 0
    scheduler_stats.running_processes = 0
    scheduler_stats.waiting_processes = 0
    scheduler_stats.cultural_processes = 0
    scheduler_stats.context_switches = 0
    scheduler_stats.average_wait_time = 0
    scheduler_stats.average_turnaround_time = 0
    scheduler_stats.cpu_utilization = 0.0
    scheduler_stats.gotong_royong_efficiency = 0.0
    
    khat_log("[SCHEDULER] Scheduler gotong royong berhasil diinisialisasi!")
    return 0
}

// Add process to scheduler
fungsi scheduler_add_process(pid: int, priority: int) -> int {
    if (pid < 0 || priority < MIN_PRIORITY || priority > MAX_PRIORITY) {
        return -1
    }
    
    acquire_lock(&scheduler_lock)
    
    // Initialize scheduling info
    var info = &process_scheduling_info[pid]
    info->pid = pid
    info->priority = priority
    info->priority_class = determine_priority_class(pid)
    info->time_slice = calculate_time_slice(priority, info->priority_class)
    info->cpu_time_used = 0
    info->wait_time = 0
    info->last_scheduled = 0
    info->cultural_priority = is_cultural_process(pid)
    info->gotong_royong_contribution = 0
    info->scheduling_count = 0
    info->context_switches = 0
    
    // Apply cultural priority boost
    if (info->cultural_priority) {
        priority = min(priority + CULTURAL_PRIORITY_BOOST, MAX_PRIORITY)
        scheduler_stats.cultural_processes++
    }
    
    // Add to appropriate queue
    var queue = &scheduler_queues[priority]
    if (queue->process_count < 1024) {
        queue->processes[queue->process_count] = pid
        queue->process_count++
        
        scheduler_stats.total_processes++
        scheduler_stats.waiting_processes++
        
        khat_log("[SCHEDULER] Process ditambahkan: PID " + khat_int_to_string(pid) + 
                 " dengan prioritas " + khat_int_to_string(priority))
    }
    
    release_lock(&scheduler_lock)
    return 0
}

// Remove process from scheduler
fungsi scheduler_remove_process(pid: int) -> int {
    if (pid < 0) {
        return -1
    }
    
    acquire_lock(&scheduler_lock)
    
    var info = &process_scheduling_info[pid]
    var priority = info->priority
    
    // Apply cultural boost if needed
    if (info->cultural_priority) {
        priority = min(priority + CULTURAL_PRIORITY_BOOST, MAX_PRIORITY)
        scheduler_stats.cultural_processes--
    }
    
    // Remove from queue
    var queue = &scheduler_queues[priority]
    var found = false
    
    for (var i = 0; i < queue->process_count; i++) {
        if (queue->processes[i] == pid) {
            // Shift remaining processes
            for (var j = i; j < queue->process_count - 1; j++) {
                queue->processes[j] = queue->processes[j + 1]
            }
            queue->process_count--
            found = true
            break
        }
    }
    
    if (found) {
        scheduler_stats.total_processes--
        scheduler_stats.waiting_processes--
        
        // Reset scheduling info
        info->pid = -1
        
        khat_log("[SCHEDULER] Process dihapus: PID " + khat_int_to_string(pid))
    }
    
    release_lock(&scheduler_lock)
    return found ? 0 : -1
}

// Get next process to schedule
fungsi scheduler_get_next_process() -> int {
    acquire_lock(&scheduler_lock)
    
    var next_pid = -1
    var current_time = get_current_time()
    
    switch (current_algorithm) {
        case ROUND_ROBIN:
            next_pid = schedule_round_robin()
            break
        case PRIORITY:
            next_pid = schedule_priority()
            break
        case GOTONG_ROYONG:
            next_pid = schedule_gotong_royong()
            break
        case CULTURAL_AWARE:
            next_pid = schedule_cultural_aware()
            break
        case REAL_TIME:
            next_pid = schedule_real_time()
            break
        default:
            next_pid = schedule_gotong_royong()
            break
    }
    
    // Update scheduling statistics
    if (next_pid >= 0) {
        update_scheduling_stats(next_pid, current_time)
    }
    
    last_schedule_time = current_time
    
    release_lock(&scheduler_lock)
    return next_pid
}

// Gotong royong scheduling algorithm
fungsi schedule_gotong_royong() -> int {
    var best_pid = -1
    var best_score = -1
    var current_time = get_current_time()
    
    // Scan all queues from highest to lowest priority
    for (var priority = MAX_PRIORITY; priority >= MIN_PRIORITY; priority--) {
        var queue = &scheduler_queues[priority]
        
        if (queue->process_count == 0) {
            continue
        }
        
        // Find process with best gotong royong score
        for (var i = 0; i < queue->process_count; i++) {
            var pid = queue->processes[i]
            var info = &process_scheduling_info[pid]
            
            // Calculate gotong royong score
            var score = calculate_gotong_royong_score(pid, current_time)
            
            if (score > best_score) {
                best_score = score
                best_pid = pid
            }
        }
        
        // If we found a good candidate, use it
        if (best_pid >= 0) {
            break
        }
    }
    
    return best_pid
}

// Calculate gotong royong score
fungsi calculate_gotong_royong_score(pid: int, current_time: time_t) -> int {
    var info = &process_scheduling_info[pid]
    var score = 0
    
    // Base priority score
    score += info->priority * 10
    
    // Cultural priority boost
    if (info->cultural_priority) {
        score += 50
    }
    
    // Wait time factor (longer wait = higher score)
    var wait_time = current_time - info->last_scheduled
    score += (int)(wait_time / 1000)  // Convert to seconds
    
    // Gotong royong contribution factor
    score += info->gotong_royong_contribution * 5
    
    // Fairness factor (less scheduled = higher score)
    if (info->scheduling_count > 0) {
        score -= info->scheduling_count / 10
    }
    
    // Priority class bonus
    switch (info->priority_class) {
        case REAL_TIME:
            score += 100
            break
        case SYSTEM:
            score += 75
            break
        case CULTURAL:
            score += 60
            break
        case HIGH:
            score += 40
            break
        case NORMAL:
            score += 20
            break
        case IDLE:
            score += 0
            break
    }
    
    return score
}

// Cultural aware scheduling
fungsi schedule_cultural_aware() -> int {
    var current_time = get_current_time()
    
    // First, check for cultural processes
    for (var priority = MAX_PRIORITY; priority >= MIN_PRIORITY; priority--) {
        var queue = &scheduler_queues[priority]
        
        for (var i = 0; i < queue->process_count; i++) {
            var pid = queue->processes[i]
            var info = &process_scheduling_info[pid]
            
            if (info->cultural_priority) {
                // Check if cultural process needs immediate attention
                if (needs_cultural_attention(pid, current_time)) {
                    return pid
                }
            }
        }
    }
    
    // Fall back to regular priority scheduling
    return schedule_priority()
}

// Update process priority
fungsi scheduler_update_priority(pid: int, new_priority: int) -> int {
    if (pid < 0 || new_priority < MIN_PRIORITY || new_priority > MAX_PRIORITY) {
        return -1
    }
    
    acquire_lock(&scheduler_lock)
    
    var info = &process_scheduling_info[pid]
    var old_priority = info->priority
    
    // Apply cultural boost if needed
    if (info->cultural_priority) {
        old_priority = min(old_priority + CULTURAL_PRIORITY_BOOST, MAX_PRIORITY)
        new_priority = min(new_priority + CULTURAL_PRIORITY_BOOST, MAX_PRIORITY)
    }
    
    // Remove from old queue
    var old_queue = &scheduler_queues[old_priority]
    var found = false
    
    for (var i = 0; i < old_queue->process_count; i++) {
        if (old_queue->processes[i] == pid) {
            // Shift remaining processes
            for (var j = i; j < old_queue->process_count - 1; j++) {
                old_queue->processes[j] = old_queue->processes[j + 1]
            }
            old_queue->process_count--
            found = true
            break
        }
    }
    
    if (found) {
        // Update priority
        info->priority = new_priority
        
        // Add to new queue
        var new_queue = &scheduler_queues[new_priority]
        if (new_queue->process_count < 1024) {
            new_queue->processes[new_queue->process_count] = pid
            new_queue->process_count++
        }
        
        khat_log("[SCHEDULER] Priority updated: PID " + khat_int_to_string(pid) + 
                 " dari " + khat_int_to_string(info->priority) + 
                 " ke " + khat_int_to_string(new_priority))
    }
    
    release_lock(&scheduler_lock)
    return found ? 0 : -1
}

// Boost cultural processes
fungsi boost_cultural_processes() -> void {
    acquire_lock(&scheduler_lock)
    
    var boosted_count = 0
    
    for (var i = 0; i < 1024; i++) {
        var info = &process_scheduling_info[i]
        
        if (info->pid >= 0 && info->cultural_priority) {
            // Temporarily boost priority
            var current_priority = info->priority
            var boosted_priority = min(current_priority + CULTURAL_PRIORITY_BOOST, MAX_PRIORITY)
            
            if (boosted_priority != current_priority) {
                scheduler_update_priority(info->pid, boosted_priority)
                boosted_count++
            }
        }
    }
    
    if (boosted_count > 0) {
        khat_log("[SCHEDULER] Boosted " + khat_int_to_string(boosted_count) + " cultural processes")
    }
    
    release_lock(&scheduler_lock)
}

// Handle time slice expiration
fungsi scheduler_time_slice_expired(pid: int) -> void {
    if (pid < 0) {
        return
    }
    
    var info = &process_scheduling_info[pid]
    var current_time = get_current_time()
    
    // Update CPU time
    info->cpu_time_used += info->time_slice
    
    // Update gotong royong contribution
    info->gotong_royong_contribution++
    
    // Check if process should yield to others
    if (should_yield_for_gotong_royong(pid)) {
        // Temporarily lower priority to give others a chance
        var new_priority = max(info->priority - 1, MIN_PRIORITY)
        scheduler_update_priority(pid, new_priority)
        
        khat_log("[SCHEDULER] Process " + khat_int_to_string(pid) + " yields for gotong royong")
    }
}

// Get scheduler statistics
fungsi scheduler_get_statistics() -> SchedulerStats* {
    update_scheduler_statistics()
    return &scheduler_stats
}

// Update scheduler statistics
fungsi update_scheduler_statistics() -> void {
    var current_time = get_current_time()
    var total_wait_time: time_t = 0
    var process_count = 0
    
    // Calculate average wait time
    for (var i = 0; i < 1024; i++) {
        var info = &process_scheduling_info[i]
        if (info->pid >= 0) {
            total_wait_time += info->wait_time
            process_count++
        }
    }
    
    if (process_count > 0) {
        scheduler_stats.average_wait_time = total_wait_time / process_count
    }
    
    // Calculate gotong royong efficiency
    scheduler_stats.gotong_royong_efficiency = calculate_gotong_royong_efficiency()
    
    // Update CPU utilization
    scheduler_stats.cpu_utilization = calculate_cpu_utilization()
}

// Shutdown scheduler
fungsi scheduler_shutdown() -> void {
    khat_log("[SCHEDULER] Mematikan scheduler...")
    
    // Clear all queues
    for (var i = 0; i <= MAX_PRIORITY; i++) {
        scheduler_queues[i].process_count = 0
    }
    
    // Reset statistics
    scheduler_stats.total_processes = 0
    scheduler_stats.running_processes = 0
    scheduler_stats.waiting_processes = 0
    
    khat_log("[SCHEDULER] Scheduler telah dimatikan")
}
